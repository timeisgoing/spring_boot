事物的4特性 (原子一直永久隔离)
原子性 最小粒度,不可再分,要么成功要么回滚
一致性 转账的扣费和收费是一致的,成功全成功,失败全失败,一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。
隔离性 a的成功与否不影响b,并发多个事物不相互影响
永久性 事物一旦发生就持久化下来,不会变更,一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的

5中隔离级别
事物的隔离为了应对事物的三种问题: 脏不换
    脏读:读取了别人还没提交的数据
    不可重复读:读取两次的结果不同,因为有另一个事物在两次读取之间修改了数据, 重点在于数据被修改了.
              (大部分数据库缺省的事物隔离级别都不会出现这种状况)
    幻读: 读取两次的结果不同,因为有另一个事物在两次读取之间增加或者删除了数据, 重点在于数据被增删了.
         (大部分数据库缺省的事物隔离级别都会出现这种状况，此种事物隔离级别将带来表级锁)

isolation_default,也有叫做default,使用后端数据默认的隔离级别,对于大多数的数据库来说，默认的隔离级别都是read_commted
isolation_read_uncommit 允许事物读取 其他事物提交的变更增删,脏读,不可重复读,幻读都会出现,最不安全(几乎不用)
isolation_read_commit 允许事物读取已经被其他事物提交的修改增删,避免脏读现象 （Oracle 默认级别)  (最常用)
isolation_reapeatable_read 可避免脏读和可重复读,幻读任然在 （MYSQL默认级别）
isolation_serializable 所有问题都可以避免，通过完全锁定当前事务所涉及的数据表来完成的。但性能十分低下。

          
                  脏读     不可重复读      幻读
Read uncommitted   √         √           √
Read committed     ×         √           √
reapeatable_read   ×         ×           √
serializable       ×         ×           ×




7种传播机制

要不要事物:
  要:是不是开启新事物
required: 有事物就不开,没有才开---- 如果有事务在运行，当前的方法就在该事务中运行，否则启动新的一个事务
required_new:必须开新事物---- 当前的方法必须启动新的事务，并在它自己的事务内运行。如果有事务正在运行，应该将它挂起

  要不要事物皆可:
supports:如果有事务在运行，当前方法在这个事务运行，否则它可以不运行在事务中

  必须有事物:
mandatory：必须有事物   当前的方法必须运行在事务内部，如果没有运行的事务，就抛出异常
   内嵌事物:
nested：如果有事务在运行，当前的方法就应该在这个事务的嵌套事务内运行，否则就启动一个新的事务，并在它自己的事务内运行。

  不要事物
not_supports：当前的方法不应该运行在事务中。如果有事务运行，将它挂起
never：当前方法不应该运行在事务中，如果有运行的事务，就将抛出




